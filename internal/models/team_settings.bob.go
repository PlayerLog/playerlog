// Code generated by BobGen psql v0.30.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/dm"
	"github.com/stephenafamo/bob/dialect/psql/sm"
	"github.com/stephenafamo/bob/dialect/psql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/bob/types"
)

// TeamSetting is an object representing the database table.
type TeamSetting struct {
	TeamID               string                                `db:"team_id,pk" json:"team_id"`
	PrivacyLevel         null.Val[string]                      `db:"privacy_level" json:"privacy_level"`
	StatsVisibility      null.Val[types.JSON[json.RawMessage]] `db:"stats_visibility" json:"stats_visibility"`
	MatchReminderHours   null.Val[int32]                       `db:"match_reminder_hours" json:"match_reminder_hours"`
	DefaultMatchDuration null.Val[int32]                       `db:"default_match_duration" json:"default_match_duration"`

	R teamSettingR `db:"-" json:"-"`
}

// TeamSettingSlice is an alias for a slice of pointers to TeamSetting.
// This should almost always be used instead of []*TeamSetting.
type TeamSettingSlice []*TeamSetting

// TeamSettings contains methods to work with the team_settings table
var TeamSettings = psql.NewTablex[*TeamSetting, TeamSettingSlice, *TeamSettingSetter]("", "team_settings")

// TeamSettingsQuery is a query on the team_settings table
type TeamSettingsQuery = *psql.ViewQuery[*TeamSetting, TeamSettingSlice]

// teamSettingR is where relationships are stored.
type teamSettingR struct {
	Team *Team `json:"Team"` // team_settings.team_settings_team_id_fkey
}

type teamSettingColumnNames struct {
	TeamID               string
	PrivacyLevel         string
	StatsVisibility      string
	MatchReminderHours   string
	DefaultMatchDuration string
}

var TeamSettingColumns = buildTeamSettingColumns("team_settings")

type teamSettingColumns struct {
	tableAlias           string
	TeamID               psql.Expression
	PrivacyLevel         psql.Expression
	StatsVisibility      psql.Expression
	MatchReminderHours   psql.Expression
	DefaultMatchDuration psql.Expression
}

func (c teamSettingColumns) Alias() string {
	return c.tableAlias
}

func (teamSettingColumns) AliasedAs(alias string) teamSettingColumns {
	return buildTeamSettingColumns(alias)
}

func buildTeamSettingColumns(alias string) teamSettingColumns {
	return teamSettingColumns{
		tableAlias:           alias,
		TeamID:               psql.Quote(alias, "team_id"),
		PrivacyLevel:         psql.Quote(alias, "privacy_level"),
		StatsVisibility:      psql.Quote(alias, "stats_visibility"),
		MatchReminderHours:   psql.Quote(alias, "match_reminder_hours"),
		DefaultMatchDuration: psql.Quote(alias, "default_match_duration"),
	}
}

type teamSettingWhere[Q psql.Filterable] struct {
	TeamID               psql.WhereMod[Q, string]
	PrivacyLevel         psql.WhereNullMod[Q, string]
	StatsVisibility      psql.WhereNullMod[Q, types.JSON[json.RawMessage]]
	MatchReminderHours   psql.WhereNullMod[Q, int32]
	DefaultMatchDuration psql.WhereNullMod[Q, int32]
}

func (teamSettingWhere[Q]) AliasedAs(alias string) teamSettingWhere[Q] {
	return buildTeamSettingWhere[Q](buildTeamSettingColumns(alias))
}

func buildTeamSettingWhere[Q psql.Filterable](cols teamSettingColumns) teamSettingWhere[Q] {
	return teamSettingWhere[Q]{
		TeamID:               psql.Where[Q, string](cols.TeamID),
		PrivacyLevel:         psql.WhereNull[Q, string](cols.PrivacyLevel),
		StatsVisibility:      psql.WhereNull[Q, types.JSON[json.RawMessage]](cols.StatsVisibility),
		MatchReminderHours:   psql.WhereNull[Q, int32](cols.MatchReminderHours),
		DefaultMatchDuration: psql.WhereNull[Q, int32](cols.DefaultMatchDuration),
	}
}

// TeamSettingSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type TeamSettingSetter struct {
	TeamID               omit.Val[string]                          `db:"team_id,pk" json:"team_id"`
	PrivacyLevel         omitnull.Val[string]                      `db:"privacy_level" json:"privacy_level"`
	StatsVisibility      omitnull.Val[types.JSON[json.RawMessage]] `db:"stats_visibility" json:"stats_visibility"`
	MatchReminderHours   omitnull.Val[int32]                       `db:"match_reminder_hours" json:"match_reminder_hours"`
	DefaultMatchDuration omitnull.Val[int32]                       `db:"default_match_duration" json:"default_match_duration"`
}

func (s TeamSettingSetter) SetColumns() []string {
	vals := make([]string, 0, 5)
	if !s.TeamID.IsUnset() {
		vals = append(vals, "team_id")
	}

	if !s.PrivacyLevel.IsUnset() {
		vals = append(vals, "privacy_level")
	}

	if !s.StatsVisibility.IsUnset() {
		vals = append(vals, "stats_visibility")
	}

	if !s.MatchReminderHours.IsUnset() {
		vals = append(vals, "match_reminder_hours")
	}

	if !s.DefaultMatchDuration.IsUnset() {
		vals = append(vals, "default_match_duration")
	}

	return vals
}

func (s TeamSettingSetter) Overwrite(t *TeamSetting) {
	if !s.TeamID.IsUnset() {
		t.TeamID, _ = s.TeamID.Get()
	}
	if !s.PrivacyLevel.IsUnset() {
		t.PrivacyLevel, _ = s.PrivacyLevel.GetNull()
	}
	if !s.StatsVisibility.IsUnset() {
		t.StatsVisibility, _ = s.StatsVisibility.GetNull()
	}
	if !s.MatchReminderHours.IsUnset() {
		t.MatchReminderHours, _ = s.MatchReminderHours.GetNull()
	}
	if !s.DefaultMatchDuration.IsUnset() {
		t.DefaultMatchDuration, _ = s.DefaultMatchDuration.GetNull()
	}
}

func (s *TeamSettingSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return TeamSettings.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		vals := make([]bob.Expression, 5)
		if s.TeamID.IsUnset() {
			vals[0] = psql.Raw("DEFAULT")
		} else {
			vals[0] = psql.Arg(s.TeamID)
		}

		if s.PrivacyLevel.IsUnset() {
			vals[1] = psql.Raw("DEFAULT")
		} else {
			vals[1] = psql.Arg(s.PrivacyLevel)
		}

		if s.StatsVisibility.IsUnset() {
			vals[2] = psql.Raw("DEFAULT")
		} else {
			vals[2] = psql.Arg(s.StatsVisibility)
		}

		if s.MatchReminderHours.IsUnset() {
			vals[3] = psql.Raw("DEFAULT")
		} else {
			vals[3] = psql.Arg(s.MatchReminderHours)
		}

		if s.DefaultMatchDuration.IsUnset() {
			vals[4] = psql.Raw("DEFAULT")
		} else {
			vals[4] = psql.Arg(s.DefaultMatchDuration)
		}

		return bob.ExpressSlice(ctx, w, d, start, vals, "", ", ", "")
	}))
}

func (s TeamSettingSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions()...)
}

func (s TeamSettingSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 5)

	if !s.TeamID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "team_id")...),
			psql.Arg(s.TeamID),
		}})
	}

	if !s.PrivacyLevel.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "privacy_level")...),
			psql.Arg(s.PrivacyLevel),
		}})
	}

	if !s.StatsVisibility.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "stats_visibility")...),
			psql.Arg(s.StatsVisibility),
		}})
	}

	if !s.MatchReminderHours.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "match_reminder_hours")...),
			psql.Arg(s.MatchReminderHours),
		}})
	}

	if !s.DefaultMatchDuration.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			psql.Quote(append(prefix, "default_match_duration")...),
			psql.Arg(s.DefaultMatchDuration),
		}})
	}

	return exprs
}

// FindTeamSetting retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindTeamSetting(ctx context.Context, exec bob.Executor, TeamIDPK string, cols ...string) (*TeamSetting, error) {
	if len(cols) == 0 {
		return TeamSettings.Query(
			SelectWhere.TeamSettings.TeamID.EQ(TeamIDPK),
		).One(ctx, exec)
	}

	return TeamSettings.Query(
		SelectWhere.TeamSettings.TeamID.EQ(TeamIDPK),
		sm.Columns(TeamSettings.Columns().Only(cols...)),
	).One(ctx, exec)
}

// TeamSettingExists checks the presence of a single record by primary key
func TeamSettingExists(ctx context.Context, exec bob.Executor, TeamIDPK string) (bool, error) {
	return TeamSettings.Query(
		SelectWhere.TeamSettings.TeamID.EQ(TeamIDPK),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after TeamSetting is retrieved from the database
func (o *TeamSetting) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = TeamSettings.AfterSelectHooks.RunHooks(ctx, exec, TeamSettingSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = TeamSettings.AfterInsertHooks.RunHooks(ctx, exec, TeamSettingSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = TeamSettings.AfterUpdateHooks.RunHooks(ctx, exec, TeamSettingSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = TeamSettings.AfterDeleteHooks.RunHooks(ctx, exec, TeamSettingSlice{o})
	}

	return err
}

// PrimaryKeyVals returns the primary key values of the TeamSetting
func (o *TeamSetting) PrimaryKeyVals() bob.Expression {
	return psql.Arg(o.TeamID)
}

func (o *TeamSetting) pkEQ() dialect.Expression {
	return psql.Quote("team_settings", "team_id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		return o.PrimaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the TeamSetting
func (o *TeamSetting) Update(ctx context.Context, exec bob.Executor, s *TeamSettingSetter) error {
	v, err := TeamSettings.Update(s.UpdateMod(), um.Where(o.pkEQ())).One(ctx, exec)
	if err != nil {
		return err
	}

	o.R = v.R
	*o = *v

	return nil
}

// Delete deletes a single TeamSetting record with an executor
func (o *TeamSetting) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := TeamSettings.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the TeamSetting using the executor
func (o *TeamSetting) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := TeamSettings.Query(
		SelectWhere.TeamSettings.TeamID.EQ(o.TeamID),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after TeamSettingSlice is retrieved from the database
func (o TeamSettingSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = TeamSettings.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = TeamSettings.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = TeamSettings.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = TeamSettings.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o TeamSettingSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return psql.Raw("NULL")
	}

	return psql.Quote("team_settings", "team_id").In(bob.ExpressionFunc(func(ctx context.Context, w io.Writer, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.PrimaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o TeamSettingSlice) copyMatchingRows(from ...*TeamSetting) {
	for i, old := range o {
		for _, new := range from {
			if new.TeamID != old.TeamID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o TeamSettingSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return TeamSettings.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *TeamSetting:
				o.copyMatchingRows(retrieved)
			case []*TeamSetting:
				o.copyMatchingRows(retrieved...)
			case TeamSettingSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a TeamSetting or a slice of TeamSetting
				// then run the AfterUpdateHooks on the slice
				_, err = TeamSettings.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o TeamSettingSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return TeamSettings.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *TeamSetting:
				o.copyMatchingRows(retrieved)
			case []*TeamSetting:
				o.copyMatchingRows(retrieved...)
			case TeamSettingSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a TeamSetting or a slice of TeamSetting
				// then run the AfterDeleteHooks on the slice
				_, err = TeamSettings.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o TeamSettingSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals TeamSettingSetter) error {
	if len(o) == 0 {
		return nil
	}

	_, err := TeamSettings.Update(vals.UpdateMod(), o.UpdateMod()).All(ctx, exec)
	return err
}

func (o TeamSettingSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := TeamSettings.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o TeamSettingSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := TeamSettings.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

type teamSettingJoins[Q dialect.Joinable] struct {
	typ  string
	Team func(context.Context) modAs[Q, teamColumns]
}

func (j teamSettingJoins[Q]) aliasedAs(alias string) teamSettingJoins[Q] {
	return buildTeamSettingJoins[Q](buildTeamSettingColumns(alias), j.typ)
}

func buildTeamSettingJoins[Q dialect.Joinable](cols teamSettingColumns, typ string) teamSettingJoins[Q] {
	return teamSettingJoins[Q]{
		typ:  typ,
		Team: teamSettingsJoinTeam[Q](cols, typ),
	}
}

func teamSettingsJoinTeam[Q dialect.Joinable](from teamSettingColumns, typ string) func(context.Context) modAs[Q, teamColumns] {
	return func(ctx context.Context) modAs[Q, teamColumns] {
		return modAs[Q, teamColumns]{
			c: TeamColumns,
			f: func(to teamColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Teams.Name().As(to.Alias())).On(
						to.ID.EQ(from.TeamID),
					))
				}

				return mods
			},
		}
	}
}

// Team starts a query for related objects on teams
func (o *TeamSetting) Team(mods ...bob.Mod[*dialect.SelectQuery]) TeamsQuery {
	return Teams.Query(append(mods,
		sm.Where(TeamColumns.ID.EQ(psql.Arg(o.TeamID))),
	)...)
}

func (os TeamSettingSlice) Team(mods ...bob.Mod[*dialect.SelectQuery]) TeamsQuery {
	PKArgs := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgs[i] = psql.ArgGroup(o.TeamID)
	}

	return Teams.Query(append(mods,
		sm.Where(psql.Group(TeamColumns.ID).In(PKArgs...)),
	)...)
}

func (o *TeamSetting) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "Team":
		rel, ok := retrieved.(*Team)
		if !ok {
			return fmt.Errorf("teamSetting cannot load %T as %q", retrieved, name)
		}

		o.R.Team = rel

		if rel != nil {
			rel.R.TeamSetting = o
		}
		return nil
	default:
		return fmt.Errorf("teamSetting has no relationship %q", name)
	}
}

func PreloadTeamSettingTeam(opts ...psql.PreloadOption) psql.Preloader {
	return psql.Preload[*Team, TeamSlice](orm.Relationship{
		Name: "Team",
		Sides: []orm.RelSide{
			{
				From: TableNames.TeamSettings,
				To:   TableNames.Teams,
				FromColumns: []string{
					ColumnNames.TeamSettings.TeamID,
				},
				ToColumns: []string{
					ColumnNames.Teams.ID,
				},
			},
		},
	}, Teams.Columns().Names(), opts...)
}

func ThenLoadTeamSettingTeam(queryMods ...bob.Mod[*dialect.SelectQuery]) psql.Loader {
	return psql.Loader(func(ctx context.Context, exec bob.Executor, retrieved any) error {
		loader, isLoader := retrieved.(interface {
			LoadTeamSettingTeam(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
		})
		if !isLoader {
			return fmt.Errorf("object %T cannot load TeamSettingTeam", retrieved)
		}

		err := loader.LoadTeamSettingTeam(ctx, exec, queryMods...)

		// Don't cause an issue due to missing relationships
		if errors.Is(err, sql.ErrNoRows) {
			return nil
		}

		return err
	})
}

// LoadTeamSettingTeam loads the teamSetting's Team into the .R struct
func (o *TeamSetting) LoadTeamSettingTeam(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Team = nil

	related, err := o.Team(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.TeamSetting = o

	o.R.Team = related
	return nil
}

// LoadTeamSettingTeam loads the teamSetting's Team into the .R struct
func (os TeamSettingSlice) LoadTeamSettingTeam(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	teams, err := os.Team(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		for _, rel := range teams {
			if o.TeamID != rel.ID {
				continue
			}

			rel.R.TeamSetting = o

			o.R.Team = rel
			break
		}
	}

	return nil
}

func attachTeamSettingTeam0(ctx context.Context, exec bob.Executor, count int, teamSetting0 *TeamSetting, team1 *Team) (*TeamSetting, error) {
	setter := &TeamSettingSetter{
		TeamID: omit.From(team1.ID),
	}

	err := teamSetting0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachTeamSettingTeam0: %w", err)
	}

	return teamSetting0, nil
}

func (teamSetting0 *TeamSetting) InsertTeam(ctx context.Context, exec bob.Executor, related *TeamSetter) error {
	team1, err := Teams.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachTeamSettingTeam0(ctx, exec, 1, teamSetting0, team1)
	if err != nil {
		return err
	}

	teamSetting0.R.Team = team1

	team1.R.TeamSetting = teamSetting0

	return nil
}

func (teamSetting0 *TeamSetting) AttachTeam(ctx context.Context, exec bob.Executor, team1 *Team) error {
	var err error

	_, err = attachTeamSettingTeam0(ctx, exec, 1, teamSetting0, team1)
	if err != nil {
		return err
	}

	teamSetting0.R.Team = team1

	team1.R.TeamSetting = teamSetting0

	return nil
}
