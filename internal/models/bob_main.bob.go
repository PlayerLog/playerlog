// Code generated by BobGen psql v0.30.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"hash/maphash"

	"github.com/lib/pq"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
)

var TableNames = struct {
	TeamMembers  string
	TeamSettings string
	Teams        string
	UserSettings string
	Users        string
}{
	TeamMembers:  "team_members",
	TeamSettings: "team_settings",
	Teams:        "teams",
	UserSettings: "user_settings",
	Users:        "users",
}

var ColumnNames = struct {
	TeamMembers  teamMemberColumnNames
	TeamSettings teamSettingColumnNames
	Teams        teamColumnNames
	UserSettings userSettingColumnNames
	Users        userColumnNames
}{
	TeamMembers: teamMemberColumnNames{
		UserID:       "user_id",
		TeamID:       "team_id",
		Role:         "role",
		JerseyNumber: "jersey_number",
		Position:     "position",
		JoinedAt:     "joined_at",
	},
	TeamSettings: teamSettingColumnNames{
		TeamID:               "team_id",
		PrivacyLevel:         "privacy_level",
		StatsVisibility:      "stats_visibility",
		MatchReminderHours:   "match_reminder_hours",
		DefaultMatchDuration: "default_match_duration",
	},
	Teams: teamColumnNames{
		ID:             "id",
		Name:           "name",
		ShortName:      "short_name",
		LogoURL:        "logo_url",
		PrimaryColor:   "primary_color",
		SecondaryColor: "secondary_color",
		SportType:      "sport_type",
		Division:       "division",
		Season:         "season",
		IsActive:       "is_active",
		CreatedAt:      "created_at",
		UpdatedAt:      "updated_at",
	},
	UserSettings: userSettingColumnNames{
		UserID:                  "user_id",
		NotificationPreferences: "notification_preferences",
		Theme:                   "theme",
		Language:                "language",
		Timezone:                "timezone",
	},
	Users: userColumnNames{
		ID:           "id",
		Email:        "email",
		PasswordHash: "password_hash",
		FirstName:    "first_name",
		LastName:     "last_name",
		Role:         "role",
		Phone:        "phone",
		IsActive:     "is_active",
		LastLogin:    "last_login",
		CreatedAt:    "created_at",
		UpdatedAt:    "updated_at",
	},
}

var (
	SelectWhere = Where[*dialect.SelectQuery]()
	InsertWhere = Where[*dialect.InsertQuery]()
	UpdateWhere = Where[*dialect.UpdateQuery]()
	DeleteWhere = Where[*dialect.DeleteQuery]()
)

func Where[Q psql.Filterable]() struct {
	TeamMembers  teamMemberWhere[Q]
	TeamSettings teamSettingWhere[Q]
	Teams        teamWhere[Q]
	UserSettings userSettingWhere[Q]
	Users        userWhere[Q]
} {
	return struct {
		TeamMembers  teamMemberWhere[Q]
		TeamSettings teamSettingWhere[Q]
		Teams        teamWhere[Q]
		UserSettings userSettingWhere[Q]
		Users        userWhere[Q]
	}{
		TeamMembers:  buildTeamMemberWhere[Q](TeamMemberColumns),
		TeamSettings: buildTeamSettingWhere[Q](TeamSettingColumns),
		Teams:        buildTeamWhere[Q](TeamColumns),
		UserSettings: buildUserSettingWhere[Q](UserSettingColumns),
		Users:        buildUserWhere[Q](UserColumns),
	}
}

var (
	SelectJoins = getJoins[*dialect.SelectQuery]()
	UpdateJoins = getJoins[*dialect.UpdateQuery]()
	DeleteJoins = getJoins[*dialect.DeleteQuery]()
)

type joinSet[Q interface{ aliasedAs(string) Q }] struct {
	InnerJoin Q
	LeftJoin  Q
	RightJoin Q
}

func (j joinSet[Q]) AliasedAs(alias string) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: j.InnerJoin.aliasedAs(alias),
		LeftJoin:  j.LeftJoin.aliasedAs(alias),
		RightJoin: j.RightJoin.aliasedAs(alias),
	}
}

type joins[Q dialect.Joinable] struct {
	TeamMembers  joinSet[teamMemberJoins[Q]]
	TeamSettings joinSet[teamSettingJoins[Q]]
	Teams        joinSet[teamJoins[Q]]
	UserSettings joinSet[userSettingJoins[Q]]
	Users        joinSet[userJoins[Q]]
}

func buildJoinSet[Q interface{ aliasedAs(string) Q }, C any, F func(C, string) Q](c C, f F) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: f(c, clause.InnerJoin),
		LeftJoin:  f(c, clause.LeftJoin),
		RightJoin: f(c, clause.RightJoin),
	}
}

func getJoins[Q dialect.Joinable]() joins[Q] {
	return joins[Q]{
		TeamMembers:  buildJoinSet[teamMemberJoins[Q]](TeamMemberColumns, buildTeamMemberJoins),
		TeamSettings: buildJoinSet[teamSettingJoins[Q]](TeamSettingColumns, buildTeamSettingJoins),
		Teams:        buildJoinSet[teamJoins[Q]](TeamColumns, buildTeamJoins),
		UserSettings: buildJoinSet[userSettingJoins[Q]](UserSettingColumns, buildUserSettingJoins),
		Users:        buildJoinSet[userJoins[Q]](UserColumns, buildUserJoins),
	}
}

type modAs[Q any, C interface{ AliasedAs(string) C }] struct {
	c C
	f func(C) bob.Mod[Q]
}

func (m modAs[Q, C]) Apply(q Q) {
	m.f(m.c).Apply(q)
}

func (m modAs[Q, C]) AliasedAs(alias string) bob.Mod[Q] {
	m.c = m.c.AliasedAs(alias)
	return m
}

func randInt() int64 {
	out := int64(new(maphash.Hash).Sum64())

	if out < 0 {
		return -out % 10000
	}

	return out % 10000
}

// ErrUniqueConstraint captures all unique constraint errors by explicitly leaving `s` empty.
var ErrUniqueConstraint = &UniqueConstraintError{s: ""}

type UniqueConstraintError struct {
	// s is a string uniquely identifying the constraint in the raw error message returned from the database.
	s string
}

func (e *UniqueConstraintError) Error() string {
	return e.s
}

func (e *UniqueConstraintError) Is(target error) bool {
	err, ok := target.(*pq.Error)
	if !ok {
		return false
	}
	return err.Code == "23505" && (e.s == "" || err.Constraint == e.s)
}
